module QuantifierSeqCalc

open System
open Expr


//========================================================================
//TODO:

//Сокращение повторений:
// F -> D1 A A D2
//-----------------
// F -> D1 A D2

//Сокращение повторений:
// F1 A A F2 -> D
//-----------------
// F1 A F2 -> D

//Усечения:
// F1 A F2, F -> D1 A D2
//------------------------
// F1 F2 F -> D1 D2 D

//========================================================================
//TODO:

// -> forall:
// F -> D1 [A][x <- y] D2
//------------------------
// F -> D1 forall_x.A D2

// exists -> :
// F1 [A][x <- y] F2 -> D
//------------------------
// F1 exists_x.A F2 -> D 

// y -- предметная переменная, не имеющая свободных 
// вхождений в заключение правила, и как терм y 
// свободен для подставновки в A вместо x.


// forall -> :
// F1 [A][x <- t] F2 ->  D
//------------------------
// F1 forall_x.A F2 ->  D

// -> exists :
// F -> D1 [A][x <- t] D2
//------------------------
// F -> D1 exists_x.A D2 

// Терм t свободен для подстановки вместо x в A

//========================================================================


let run argv =
    let (cur_der : seq list) = [argv]
    argv.ToString() |> printfn "%A"
    0                           